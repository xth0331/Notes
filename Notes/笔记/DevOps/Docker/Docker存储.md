# Docker存储

默认情况下，在荣情况内创建的所有文件都存储在可写容器层。这意味着：

- 当该容器不再存在时，数据不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。
- 容器的可写层与运行容器的主机紧密耦合。不能轻易将数据移动到其他地方。
- 写入容器的可写层需要存储驱动来管理文件系统。存储驱动程序使用LInux内核提供的联合文件系统。与使用直接写入主机文件系统的数据卷相比，额外的抽象降低了性能。

Docker为容器提供了两种选项来讲文件存储在主机中，以便即使在容器停止后文件也可以持久存储：`volumes`和`bind mounts`，如果是Linux，还可以使用`tmpfs`。Windows的话，则可以使用`named pipe`。

容器中的数据，它在容器的文件系统中显示为目录或单个文件。

`volumes`，`bind mounts`和`tmpfs mounts`之间的差异是数据在Docker主机上的位置。

![](https://blog-image.nos-eastchina1.126.net/types-of-mounts.png)

- **Volume**存储在由Docker管理的主机文件系统的一部分中（`/var/lib/docker/volumes/`）。非Docker进程不应修改文件系统的这一部分。Volume是在Docker中持久保存数据的最佳方法。
- **Bind mounts**可以存储在主机系统上的任何位置。甚至可以是重要的文件系统或目录。Docker主机或Docker容器上的非Docker进程可以随时对其进行修改。
- **tmpfs**挂载仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。

## Volume

Volume是用于持久化由Docker容器生成和使用的数据的首选机制。尽管`bind-mount`取决于主机目录结构，但`volume`完全又Docker管理。相较于`bind-mount`，具有以下几个优点：

- 更易于备份和迁移。
- 可以使用`Docker CLI`和`Docker API`管理。
- 可以在Windows或Linux上使用。
- 可以在多个容器之间更安全地共享。
- 可以`volume`存储在远程主机或云上，以加密卷内容或添加其他功能。
- 新卷的内容可以由容器预先填充。

此外，将数据持久存储在容器的可写层中相比，`volume`通常是更好的选择，卷不会增加使用卷的容器的大小，并且卷的内容存在于给定容器的声明周期之外。

![](https://blog-image.nos-eastchina1.126.net/types-of-mounts-volume.png)

如果容器生成非持久状态数据，需要考虑使用`tmpfs`避免将数据永久存储在任何地方，并通过避免写入容器可写层来提高容器性能。

## Bind mount

自Docker诞生以来，绑定挂载就已经存在。与卷相比，绑定安装的功能有限。使用绑定安装时，会将*主机*上的文件或目录安装到容器中。文件或目录由主机上的完整或相对路径引用。相比之下，当您使用卷时，将在主机上的Docker的存储目录中创建一个新目录，并且Docker管理该目录的内容。

该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。绑定挂载性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。如果要开发新的Docker应用程序，请考虑使用命名卷。您不能使用Docker CLI命令直接管理绑定安装。

![](https://blog-image.nos-eastchina1.126.net/types-of-mounts-bind.png)

## tmpfs

与卷和绑定挂载相反，`tmpfs`挂载是临时的，并且仅保留在主机内存中。当容器停止时，`tmpfs`挂载将被删除，并且在其中写入的文件将不会保留。

![](https://blog-image.nos-eastchina1.126.net/types-of-mounts-tmpfs.png)

## 容器内存储数据

### 关于存储驱动程序

为了有效地使用存储驱动程序，了解Docker如何构建和存储映像以及容器如何使用这些映像非常重要。您可以使用此信息来做出明智的选择，以最佳方式保存应用程序中的数据并避免性能问题。

存储驱动程序使您可以在容器的可写层中创建数据。删除容器后，这些文件将不会保留，并且读写速度都低于本机文件系统性能。

> **注意**：已知有问题的操作包括写密集型数据库存储，尤其是在只写层中存在预先存在的数据时。本文档中提供了更多详细信息。

#### Image和层

Docker映像由一系列层组成。每层代表映像的Dockerfile中的一条指令。除最后一层外的每一层都是只读的。考虑以下Dockerfile：

```dockerfile
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

该Dockerfile包含四个命令，每个命令创建一个层。该 `FROM`语句首先从`ubuntu:18.04`图像创建图层。该`COPY`命令从Docker客户端的当前目录添加一些文件。该`RUN`命令使用命令构建您的应用程序`make`。最后，最后一层指定在容器中运行什么命令。

每层仅是与其之前的层的一组差异。这些层彼此堆叠。创建新容器时，可以在基础层之上添加新的可写层。该层通常称为“容器层”。对运行中的容器所做的所有更改（例如写入新文件，修改现有文件和删除文件）都将写入此薄可写容器层。下图显示了基于Ubuntu 18.04映像的容器。

![](https://blog-image.nos-eastchina1.126.net/container-layers.jpg)

一个*存储驱动程序*处理的细节有关的方式互相交流这些层。提供了不同的存储驱动程序，它们在不同情况下各有利弊。

#### 容器和层

容器和图像之间的主要区别是可写顶层。在容器中添加新数据或修改现有数据的所有写操作都存储在此可写层中。删除容器后，可写层也会被删除。基础图像保持不变。

因为每个容器都有其自己的可写容器层，并且所有更改都存储在该容器层中，所以多个容器可以共享对同一基础映像的访问，但具有自己的数据状态。下图显示了共享相同Ubuntu 18.04映像的多个容器。

![](https://blog-image.nos-eastchina1.126.net/sharing-layers.jpg)

> **注意**：如果您需要多个图像来共享对完全相同的数据的访问权限，请将此数据存储在Docker卷中并将其安装到您的容器中。

Docker使用存储驱动程序来管理图像层和可写容器层的内容。每个存储驱动程序对实现的处理方式不同，但是所有驱动程序都使用可堆叠的图像层和写时复制（CoW）策略。

#### 写入时复制（CoW）

写入时复制是一种共享和复制文件的策略，可最大程度地提高效率。如果文件或目录位于映像的较低层中，而另一层（包括可写层）需要对其进行读取访问，则它仅使用现有文件。另一层第一次需要修改文件时（在构建映像或运行容器时），将文件复制到该层并进行修改。这样可以将I/O和每个后续层的大小最小化。

### AUFS

AUFS是联合文件系统。 aufs存储驱动程序以前是默认存储驱动程序，用于在Docker上管理Ubuntu和Ubuntu之前的Debian版本中的映像和层。 如果您的Linux内核是4.0或更高版本，并且您使用的是Docker Engine-Community，请考虑使用较新的overlay2，它比aufs存储驱动程序具有潜在的性能优势。

#### `aufs`如何工作

AUFS是一个*联合文件系统*，这意味着它将在一个Linux主机上分层多个目录，并将它们显示为一个目录。这些目录在AUFS术语中称为*分支*，在Docker术语中称为*层*。

统一过程称为*联合安装*。

下图显示了基于`ubuntu:latest`映像的Docker容器。

![](https://blog-image.nos-eastchina1.126.net/aufs_layers.jpg)

每个映像层和容器层在Docker主机上均表示为中的子目录`/var/lib/docker/`。联合安装提供了所有层的统一视图。目录名称并不直接对应于图层本身的ID。

AUFS使用写时复制（CoW）策略来最大化存储效率并最小化开销。



#### 图像层

> **警告**：请勿直接操作其中的任何文件或目录 `/var/lib/docker/`。这些文件和目录由Docker管理。

有关图像和容器层的所有信息都存储在的子目录中`/var/lib/docker/aufs/`。

- `diff/`：每个图层的**内容**，每个图层的**内容**存储在单独的子目录中
- `layers/`：有关如何堆叠图像层的元数据。该目录为Docker主机上的每个图像或容器层包含一个文件。每个文件都包含堆栈中其下所有层（其父级）的ID。
- `mnt/`：安装点，每个映像或容器层一个，用于组装和安装容器的统一文件系统。对于只读图像，这些目录始终为空。

#### 容器层

如果容器正在运行，则`/var/lib/docker/aufs/`更改内容的方式如下：

- `diff/`：可写容器层中引入的差异，例如新文件或修改过的文件。
- `layers/`：有关可写容器层的父层的元数据。
- `mnt/`：每个正在运行的容器的统一文件系统的安装点，与从容器内部出现的安装点完全相同。

#### 如何容器的读取和写入与工作`aufs`

##### 读取文件

考虑三种情况，其中容器打开文件以通过aufs进行读取访问。

- **该文件在容器层中不存在**：如果容器打开文件进行读取访问，并且该文件在容器层中尚不存在，则存储驱动程序将在图像层中搜索文件，从图像层正下方的层开始容器层。从找到它的层读取它。
- **该文件仅存在于容器层中**：如果容器打开文件以进行读取访问，并且该文件存在于容器层中，则从那里进行读取。
- **该文件在容器层和图像层中都存在**：如果容器打开文件以进行读取访问，并且该文件存在于容器层和一个或多个图像层中，则从容器层读取文件。容器层中的文件会使图像层中具有相同名称的文件模糊。

##### 修改文件或目录

考虑在某些情况下修改了容器中的文件。

- **首次写入文件**：容器第一次写入现有文件时，该文件在容器（`upperdir`）中不存在。的`aufs`驾驶员进行*copy_up*操作将文件从那里它存在到可写的容器层中的图像层复制。然后，容器将更改写入容器层中文件的新副本。

  但是，AUFS在文件级别而不是块级别工作。这意味着所有copy_up操作都将复制整个文件，即使该文件非常大且只有一小部分正在被修改。这会对容器写入性能产生明显影响。在具有多层的图像中搜索文件时，AUFS可能会出现明显的延迟。但是，值得注意的是，copy_up操作仅在第一次写入给定文件时发生。随后对同一文件的写入将对已经复制到容器的文件副本进行操作。

- **删除文件和目录**：

  - 当一个*文件*是一个容器内删除，一个*白斑*在容器层中创建的文件。不会删除图像层中文件的版本（因为图像层是只读的）。但是，白化文件会阻止容器使用它。
  - 当在容器内删除*目录时*，将在容器层中创建一个*不透明文件*。这与中断文件的工作方式相同，即使目录层仍存在于图像层中，也可以有效地防止目录被访问。

- **重命名目录**：AUFS不完全支持为目录调用`rename（2）`。 即使源路径和目标路径都在同一AUFS层上，它也会返回`EXDEV`（“不允许跨设备链接”），除非目录中没有子目录。 您的应用程序需要设计为处理`EXDEV`并退回到“复制和取消链接”策略。

### Btrfs

#### `btrfs`存储驱动程序如何工作

该`btrfs`存储驱动器的工作方式不同`devicemapper`或在您的整个其他存储驱动程序`/var/lib/docker/`目录存储在增加了Btrfs卷上。

#### 磁盘上的图像和容器层

有关图像层和可写容器层的信息存储在`/var/lib/docker/btrfs/subvolumes/`中 。该子目录每个图像或容器层包含一个目录，该统一目录由一个层及其所有父层构建而成。子卷本来就是写时复制的，并根据需要从基础存储池中分配了空间。它们也可以嵌套和快照。下图显示了4个子卷。“子卷2”和“子卷3”是嵌套的，而“子卷4”则显示其自己的内部目录树。

![子卷示例](https://blog-image.nos-eastchina1.126.net/btfs_subvolume.jpg)

仅图像的基础层存储为真实的子体积。所有其他层都存储为快照，其中仅包含该层中引入的差异。您可以如下图所示创建快照的快照。

![快照图](https://blog-image.nos-eastchina1.126.net/btfs_snapshots.jpg)

在磁盘上，快照的外观和感觉就像子卷一样，但实际上它们更小且更节省空间。写入时复制用于最大化存储效率和最小化层大小，并且在块级别管理容器可写层中的写入。下图显示了一个子卷及其快照共享数据。

![快照和子卷共享数据](https://blog-image.nos-eastchina1.126.net/btfs_pool.jpg)

为了获得最大的效率，当一个容器需要更多空间时，将以大约1 GB的*块*为单位进行分配 。

Docker的`btrfs`存储驱动程序将每个图像层和容器存储在其自己的Btrfs子卷或快照中。图像的基础层存储为子卷，而子图像层和容器存储为快照。如下图所示。

![Btrfs容器层](https://blog-image.nos-eastchina1.126.net/btfs_container_layer.jpg)

在运行`btrfs`驱动程序的Docker主机上创建映像和容器的高级过程如下：

1. 图像的基本层被存储在一增加了Btrfs *子体积*下 `/var/lib/docker/btrfs/subvolumes`。
2. 随后的图像层被存储为增加了Btrfs *快照*父层的子体积或快照的，但与此层中引入的变化。这些差异存储在块级别。
3. 容器的可写层是最终图像层的Btrfs快照，其中差异由运行中的容器引入。这些差异存储在块级别。

#### 如何容器的读取和写入与工作`btrfs`

##### 读取文件

容器是图像的节省空间的快照。快照中的元数据指向存储池中的实际数据块。这与子卷相同。因此，对快照执行的读取与对子卷执行的读取基本相同。

##### 编写文件

- **写入新文件**：**将新文件**写入容器会调用按需分配操作，以将新数据块分配给容器的快照。然后将文件写入此新空间。按需分配操作是使用Btrfs进行的所有写入所固有的，并且与将新数据写入子卷相同。结果，将新文件写入容器的快照以本机Btrfs速度运行。
- **修改现有文件**：更新容器中的现有文件是写时复制操作（写时*重定向*是Btrfs术语）。从文件当前所在的层读取原始数据，并且仅将修改后的块写入容器的可写层。接下来，Btrfs驱动程序更新快照中的文件系统元数据以指向此新数据。此行为产生很少的开销。
- **删除文件或目录**：如果容器删除了下层中存在的文件或目录，则Btrfs会掩盖下层中文件或目录的存在。如果容器创建一个文件然后将其删除，则此操作在Btrfs文件系统本身中执行，并回收空间。

使用Btrfs，写入和更新许多小文件可能会导致性能降低。

### DeviceMapper

Device Mapper是基于内核的框架，是Linux上许多高级卷管理技术的基础。Docker的`devicemapper`存储驱动程序利用此框架的精简配置和快照功能进行图像和容器管理。本文将Device Mapper存储驱动程序称为`devicemapper`，将内核框架称为*Device Mapper*。

### OverlayFS

OverlayFS在单个Linux主机上分层两个目录，并将它们显示为单个目录。这些目录称为*图层*，统一过程称为*联合安装*。OverlayFS将较低的目录称为`lowerdir`，将较高的目录称为a `upperdir`。统一视图通过其自己的目录公开`merged`。

该`overlay2`驱动程序本机最多支持128个较低的OverlayFS层。此功能为与图层相关的Docker命令（例如`docker build`和）提供了更好的性能`docker commit`，并且在备份文件系统上消耗了更少的inode。

