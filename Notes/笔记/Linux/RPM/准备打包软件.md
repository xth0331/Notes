# 准备打包软件

## 什么是源代码？

**源代码**是计算机的人类可读指令，描述了如何执行计算。源代码使用编程语言表示。

下面，使用三种不同编程语言编写`Hello World`，用着三种不同语言编写的程序以不同的方式打包。



用`bash`编写`Hello World`：

filename:`bello`

```bash
#!/bin/bash
printf "Hello World\n"
```

用`Python`编写`Hello World`：

filename:`pello.py`

```python
#!/usr/bin/env python
print("Hello World")
```

用`C`编写`Hello World`：

filename：`cello.c`

```c
#include <stdio.h>
int main（void） {
    printf("Hello World\n");
    return 0;
}
```

以上程序的结果都是在命令行上输出`Hello World`。

## 程序如何制作

人类可读的源代码有许多方法可以成为机器代码-计算机遵循实际执行程序的指令。但是，所有方法都可以简化为以下三种：

1. 程序是本地编译的。
2. 程序由原始解释来解释的。
3. 程序由字节编译解释。



### 本机编译代码

**本机编译的**软件是用编程语言**编写的**软件，编译成机器代码，生成二进制可执行文件。这种软件可以独立运行。

以这种方式构建的RPM包是特定于体系结构的。这意味着如果在64位（x86_64）处理器的计算机上编译此类软件，则无法在32位（x86）处理器上执行。生成的包将在其名称中指定体系结构。

### 解释代码

某些编程语言（`bash`或`Python`）无法编译为机器代码。相反，他们的程序的源代码是由语言解释器或语言虚拟机逐步执行的，无需事先转换。

完全用解释型编程语言编写的软件不是特定于体系结构的，因此，生成的RPM包将包含`noarch`字符串。

解释型语言或者是字节编译或原始解释。这两种类型在程序构建过程和包装过程中有所不同。

#### 原始解释程序

原始解释程序语言根本不需要编译，它们由解释器直接执行。

#### 字节编译程序

字节编译语言需要编译成字节代码，然后由语言虚拟机执行。

## 从源码构建软件

- 对于编译语言编写的软件，源代码通过**构建**（**Build**）过程生成机器代码。这个过程通常称为**编译** （**compiling**），因不同的语言而异。生成的软件可以**运行**（**run**）或**执行**（**executed**），这使计算机可以执行程序员指定的任务。
- 对于原始解释语言编写的软件，源代码不是构建的，而是直接执行。
- 对于用字节编译的解释语言编写的软件，源代码被编译成字节代码，然后由语言虚拟机执行。

### 本机编译代码

使用C语言编写的`cello.c`程序构建为可执行文件。

```c
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}
```

#### 手动构建

从GNU编译器集合（`GCC`）调用C编译器将源代码编译为二进制文件：

```bash
gcc -g -o cello cello.c
```

执行二进制文件`cello`

```bash
./cello
Hello World
```

这样，已经从源代码构建并运行本机编译的软件。

#### 自动化构建

可以自动化构建，而不是手动构建源代码。这是大型软件常用的做法。通过创建`Makefile`软件运行`GNU` `make`程序来自动完成构建。

要设置自动构建，需要创建一个名为`Makefile`和相同的`cello.c`：

Makefile:

```makefile
cello:
        gcc -g -o cello cello.c

clean:
        rm cello
```

现在构建软件，只需要运行`make`：

```bash
make
make: 'cello' is up to date.
```

由于已经有一个构建存在，可以执行`make clean`后再次运行`make`：

```bash
make clean 
rm cello 
make 
gcc -g -o cello cello.c
```



### 4.3.2. Interpreted Code

The next two examples showcase byte-compiling a program written in [Python](https://www.python.org/) and raw-interpreting a program written in [bash](https://www.gnu.org/software/bash/).

NOTE

In the two examples below, the `#!` line at the top of the file is known as a shebang and is not part of the programming language source code.

The shebang enables using a text file as an executable: the system program loader parses the line containing the **shebang** to get a path to the binary executable, which is then used as the programming language interpreter.

#### 4.3.2.1. Byte-Compiled Code

In this example, you will compile the `pello.py` program written in Python into byte code, which is then executed by the Python language virtual machine. Python source code can also be raw-interpreted, but the byte-compiled version is faster. Hence, RPM Packagers prefer to package the byte-compiled version for distribution to end users.

```
pello.py
#!/usr/bin/env python

print("Hello World")
```

Procedure for byte-compiling programs is different for different languages. It depends on the language, the language’s virtual machine, and the tools and processes used with that language.

NOTE

[Python](https://www.python.org/) is often byte-compiled, but not in the way described here. The following procedure aims not to conform to the community standards, but to be simple. For real-world Python guidelines, see [Software Packaging and Distribution](https://docs.python.org/2/library/distribution.html).

Byte-compile `pello.py`:

```bash
$ python -m compileall pello.py

$ file pello.pyc
pello.pyc: python 2.7 byte-compiled
```

Execute the byte code in `pello.pyc`:

```bash
$ python pello.pyc
Hello World
```

#### 4.3.2.2. Raw Interpreted Code

In this example, you will raw-interpret the `bello` program written in the [bash](https://www.gnu.org/software/bash/) shell built-in language.

```
bello
#!/bin/bash

printf "Hello World\n"
```

Programs written in shell scripting languages, like *bash*, are raw-interpreted. Hence, you only need to make the file with source code executable and run it:

```bash
$ chmod +x bello
$ ./bello
Hello World
```

## 4.4. Patching Software

A **patch** is source code that updates other source code. It is formatted as a *diff*, because it represents what is different between two versions of text. A *diff* is created using the `diff` utility, which is then applied to the source code using the [patch](http://savannah.gnu.org/projects/patch/) utility.

NOTE

Software developers often use Version Control Systems such as [git](https://git-scm.com/) to manage their code base. Such tools provide their own methods of creating diffs or patching software.

In the following example, we create a patch from the originial source code using `diff` and then apply it using `patch`. Patching is used in a later section when creating an RPM, [Section 5.1.7, “Working with SPEC files”](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/rpm_packaging_guide/packaging-software#working-with-spec-files).

How is patching related to RPM packaging? In packaging, instead of simply modifying the original source code, we keep it, and use patches on it.

To create a patch for `cello.c`:

1. Preserve the original source code:

   ```bash
   $ cp cello.c cello.c.orig
   ```

   This is a common way to preserve the original source code file.

2. Change `cello.c`:

   ```c
   #include <stdio.h>
   
   int main(void) {
       printf("Hello World from my very first patch!\n");
       return 0;
   }
   ```

3. Generate a patch using the `diff` utility:

   NOTE

   We use several common arguments for the `diff` utility. For more information on them, see the `diff` manual page.

   ```diff
   $ diff -Naur cello.c.orig cello.c
   --- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
   +++ cello.c     2016-05-27 14:53:20.668588245 -0500
   @@ -1,6 +1,6 @@
    #include<stdio.h>
   
    int main(void){
   -    printf("Hello World!\n");
   +    printf("Hello World from my very first patch!\n");
        return 0;
    }
   \ No newline at end of file
   ```

   Lines starting with a `-` are removed from the original source code and replaced with the lines that start with `+`.

4. Save the patch to a file:

   ```bash
   $ diff -Naur cello.c.orig cello.c > cello-output-first-patch.patch
   ```

5. Restore the original `cello.c`:

   ```bash
   $ cp cello.c.orig cello.c
   ```

   We retain the original `cello.c`, because when an RPM is built, the original file is used, not a modified one. For more information, see [Section 5.1.7, “Working with SPEC files”](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/rpm_packaging_guide/packaging-software#working-with-spec-files).

To patch `cello.c` using `cello-output-first-patch.patch`, redirect the patch file to the `patch`command:

```bash
$ patch < cello-output-first-patch.patch
patching file cello.c
```

The contents of `cello.c` now reflect the patch:

```bash
$ cat cello.c
#include<stdio.h>

int main(void){
    printf("Hello World from my very first patch!\n");
    return 1;
}
```

To build and run the patched `cello.c`:

```bash
$ make clean
rm cello

$ make
gcc -g -o cello cello.c

$ ./cello
Hello World from my very first patch!
```

You have created a patch, patched a program, built the patched program, and run it.

## 4.5. Installing Arbitrary Artifacts

A big advantage of Linux and other Unix-like systems is the Filesystem Hierarchy Standard (FHS). It specifies in which directory which files should be located. Files installed from the RPM packages should be placed according to FHS. For example, an executable file should go into a directory that is in the system PATH variable.

In the context of this guide, an *Arbitrary Artifact* is anything installed from an RPM to the system. For RPM and for the system it can be a script, a binary compiled from the package’s source code, a pre-compiled binary, or any other file.

We will explore two popular ways of placing *Arbitrary Artifacts* in the system: using the `install` command and using the `make install` command.

### 4.5.1. Using the install command

Sometimes using build automation tooling such as [GNU make](http://www.gnu.org/software/make/) is not optimal - for example, if the packaged program is simple and does not need extra overhead. In these cases, packagers often use the `install` command (provided to the system by [coreutils](http://www.gnu.org/software/coreutils/coreutils.html)), which places the artifact to the specified directory in the filesystem with a specified set of permissions.

The example below is going to use the `bello` file that we had previously created as the arbitrary artifact subject to our installation method. Note that you will either need [sudo](http://www.sudo.ws/) permissions or run this command as root excluding the `sudo` portion of the command.

In this example, `install` places the `bello` file into `/usr/bin` with permissions common for executable scripts:

```bash
$ sudo install -m 0755 bello /usr/bin/bello
```

Now `bello` is in a directory that is listed in the $PATH variable. Therefore, you can execute `bello` from any directory without specifying its full path:

```bash
$ cd ~

$ bello
Hello World
```

### 4.5.2. Using the make install command

A popular automated way to install built software to the system is to use the `make install` command. It requires you to specify how to install the arbitrary artifacts to the system in the `Makefile`.

NOTE

Usually `Makefile` is written by the developer and not by the packager.

Add the `install` section to the `Makefile`:

```
Makefile
cello:
        gcc -g -o cello cello.c

clean:
        rm cello

install:
        mkdir -p $(DESTDIR)/usr/bin
        install -m 0755 cello $(DESTDIR)/usr/bin/cello
```

The [$(DESTDIR)](https://www.gnu.org/software/make/manual/html_node/DESTDIR.html) variable is a [GNU make](http://www.gnu.org/software/make/) built-in and is commonly used to specify installation to a directory different than the root directory.

Now you can use `Makefile` not only to build software, but also to install it to the target system.

To build and install the `cello.c` program:

```bash
$ make
gcc -g -o cello cello.c

$ sudo make install
install -m 0755 cello /usr/bin/cello
```

Now `cello` is in a directory that is listed in the $PATH variable. Therefore, you can execute `cello` from any directory without specifying its full path:

```bash
$ cd ~

$ cello
Hello World
```

You have installed a build artifact into a chosen location on the system.

## 4.6. Preparing Source Code for Packaging

NOTE

The code created in this section can be found [here](https://github.com/redhat-developer/rpm-packaging-guide/tree/master/example-code).

Developers often distribute software as compressed archives of source code, which are then used to create packages. In this section, you will create such compressed archives.

NOTE

Creating source code archives is not normally done by the RPM Packager, but by the developer. The packager works with a ready source code archive.

Software should be distributed with a software license . For the examples, we will use the [GPLv3](https://www.gnu.org/licenses/quick-guide-gplv3.html) license. The license text goes into the `LICENSE` file for each of the example programs. An RPM packager needs to deal with license files when packaging.

For use with the following examples, create a `LICENSE`file:

```bash
$ cat /tmp/LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
```

## 4.7. Putting Source Code into Tarball

In the examples below, we put each of the three `Hello World` programs into a [gzip](https://www.gnu.org/software/gzip/)-compressed tarball. Software is often released this way to be later packaged for distribution.

### 4.7.1. bello

The *bello* project implements `Hello World` in [bash](https://www.gnu.org/software/bash/). The implementation only contains the `bello` shell script, so the resulting `tar.gz` archive will have only one file apart from the `LICENSE` file. Let us assume that this is version `0.1` of the program.

Prepare the *bello* project for distribution:

1. Put the files into a single directory:

   ```bash
   $ mkdir /tmp/bello-0.1
   
   $ mv ~/bello /tmp/bello-0.1/
   
   $ cp /tmp/LICENSE /tmp/bello-0.1/
   ```

2. Create the archive for distribution and move it to `~/rpmbuild/SOURCES/`:

   ```bash
   $ cd /tmp/
   
   $ tar -cvzf bello-0.1.tar.gz bello-0.1
   bello-0.1/
   bello-0.1/LICENSE
   bello-0.1/bello
   
   $ mv /tmp/bello-0.1.tar.gz ~/rpmbuild/SOURCES/
   ```

### 4.7.2. pello

The *pello* project implements `Hello World` in [Python](https://www.python.org/). The implementation only contains the `pello.py`program, so the resulting `tar.gz` archive will have only one file apart from the `LICENSE` file. Let us assume that this is version `0.1.1` of the program.

Prepare the *pello* project for distribution:

1. Put the files into a single directory:

   ```bash
   $ mkdir /tmp/pello-0.1.1
   
   $ mv ~/pello.py /tmp/pello-0.1.1/
   
   $ cp /tmp/LICENSE /tmp/pello-0.1.1/
   ```

2. Create the archive for distribution and move it to `~/rpmbuild/SOURCES/`:

   ```bash
   $ cd /tmp/
   
   $ tar -cvzf pello-0.1.1.tar.gz pello-0.1.1
   pello-0.1.1/
   pello-0.1.1/LICENSE
   pello-0.1.1/pello.py
   
   $ mv /tmp/pello-0.1.1.tar.gz ~/rpmbuild/SOURCES/
   ```

### 4.7.3. cello

The *cello* project implements `Hello World` in C . The implementation only contains the `cello.c` and `Makefile` files, so the resulting `tar.gz` archive will have only two files apart from the `LICENSE` file. Let us assume that this is version `1.0` of the program.

Note that the `patch` file is not distributed in the archive with the program. The RPM Packager applies the patch when the RPM is built. The patch will be placed in the `~/rpmbuild/SOURCES/` directory alongside the `.tar.gz`.

Prepare the *cello* project for distribution:

1. Put the files into a single directory:

   ```bash
   $ mkdir /tmp/cello-1.0
   
   $ mv ~/cello.c /tmp/cello-1.0/
   
   $ mv ~/Makefile /tmp/cello-1.0/
   
   $ cp /tmp/LICENSE /tmp/cello-1.0/
   ```

2. Create the archive for distribution and move it to `~/rpmbuild/SOURCES/`:

   ```bash
   $ cd /tmp/
   
   $ tar -cvzf cello-1.0.tar.gz cello-1.0
   cello-1.0/
   cello-1.0/Makefile
   cello-1.0/cello.c
   cello-1.0/LICENSE
   
   $ mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/
   ```

3. Add the patch:

   ```bash
   $ mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/
   ```

Now the source code is ready for packaging into an RPM.