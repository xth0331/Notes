# 准备打包软件

## 什么是源代码？

**源代码**是计算机的人类可读指令，描述了如何执行计算。源代码使用编程语言表示。

下面，使用三种不同编程语言编写`Hello World`，用着三种不同语言编写的程序以不同的方式打包。



用`bash`编写`Hello World`：

filename:`bello`

```bash
#!/bin/bash
printf "Hello World\n"
```

用`Python`编写`Hello World`：

filename:`pello.py`

```python
#!/usr/bin/env python
print("Hello World")
```

用`C`编写`Hello World`：

filename：`cello.c`

```c
#include <stdio.h>
int main（void） {
    printf("Hello World\n");
    return 0;
}
```

以上程序的结果都是在命令行上输出`Hello World`。

## 程序如何制作

人类可读的源代码有许多方法可以成为机器代码-计算机遵循实际执行程序的指令。但是，所有方法都可以简化为以下三种：

1. 程序是本地编译的。
2. 程序由原始解释来解释的。
3. 程序由字节编译解释。



### 本机编译代码

**本机编译的**软件是用编程语言**编写的**软件，编译成机器代码，生成二进制可执行文件。这种软件可以独立运行。

以这种方式构建的RPM包是特定于体系结构的。这意味着如果在64位（x86_64）处理器的计算机上编译此类软件，则无法在32位（x86）处理器上执行。生成的包将在其名称中指定体系结构。

### 解释代码

某些编程语言（`bash`或`Python`）无法编译为机器代码。相反，他们的程序的源代码是由语言解释器或语言虚拟机逐步执行的，无需事先转换。

完全用解释型编程语言编写的软件不是特定于体系结构的，因此，生成的RPM包将包含`noarch`字符串。

解释型语言或者是字节编译或原始解释。这两种类型在程序构建过程和包装过程中有所不同。

#### 原始解释程序

原始解释程序语言根本不需要编译，它们由解释器直接执行。

#### 字节编译程序

字节编译语言需要编译成字节代码，然后由语言虚拟机执行。

## 从源码构建软件

- 对于编译语言编写的软件，源代码通过**构建**（**Build**）过程生成机器代码。这个过程通常称为**编译** （**compiling**），因不同的语言而异。生成的软件可以**运行**（**run**）或**执行**（**executed**），这使计算机可以执行程序员指定的任务。
- 对于原始解释语言编写的软件，源代码不是构建的，而是直接执行。
- 对于用字节编译的解释语言编写的软件，源代码被编译成字节代码，然后由语言虚拟机执行。

### 本机编译代码

使用C语言编写的`cello.c`程序构建为可执行文件。

```c
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}
```

#### 手动构建

从GNU编译器集合（`GCC`）调用C编译器将源代码编译为二进制文件：

```bash
gcc -g -o cello cello.c
```

执行二进制文件`cello`

```bash
./cello
Hello World
```

这样，已经从源代码构建并运行本机编译的软件。

#### 自动化构建

可以自动化构建，而不是手动构建源代码。这是大型软件常用的做法。通过创建`Makefile`软件运行`GNU` `make`程序来自动完成构建。

要设置自动构建，需要创建一个名为`Makefile`和相同的`cello.c`：

Makefile:

```makefile
cello:
        gcc -g -o cello cello.c

clean:
        rm cello
```

现在构建软件，只需要运行`make`：

```bash
make
make: 'cello' is up to date.
```

由于已经有一个构建存在，可以执行`make clean`后再次运行`make`：

```bash
make clean 
rm cello 
make 
gcc -g -o cello cello.c
```



### 代码解读

#### 字节编译代码

`peool.py`用Python编写的程序编译为字节代码，然后由Python语言虚拟机执行。Pyhton源代码也可以是原始解释的，但字节编译版本更快。因此，RPM Packagers更喜欢将字节编译版本打包以分发给最终用户。

```python
#!/usr/bin/env python
print("Hello World")
```

对于不同的语言，字节编译程序的过程是不同的。取决于语言，语言的虚拟机以及与该语言一起使用的工具和过程。

字节编译：

```bash
python -m compileall pello.py
file pello.pyc
```

执行以下字节代码:

```bash
python pello.pyc
```

#### 解释代码

```bash
#!/bin/bash
printf "Hello World\n"
```

用shell脚本语言编写的程序，例如`bash`是解释的。因此，只需要使源代码可执行文件运行它：

```bash
chmod +x bello
./bello
```

## 修补软件

补丁是源代码，更新其他源代码。被格式化为`diff`因为它表示两个版本的文本之间的不同。

> 开发人员经常使用版本控制系统，例如`git`来管理源代码仓库，这些工具提供了自己创建差异或修补软件的方法。

在示例中，我们使用`diff`从原始源代码创建补丁，然后使用`patch`应用它。在创建RPM时，将在后面的部分中使用修补。

修补如何与RPM包装相关？在打包时，我们保留它，而不是简答地修改源代码，并在其上使用补丁。

在为`cello.c`内容创建补丁：

1. 保留原始源代码：

   ```bash
   cp cello.c cello.c.orig
   ```

   这是保留原始源代码文件的常用方法。

2. 更改`cello.c`:

   ```c
   #include <stdio.h>
   
   int main(void) {
       printf("Hello World from my very first patch!\n");
       return 0;
   }
   ```

3. 使用`diff`生成补丁：

   ```bash
   diff -Naur cello.c.orig cello.c
   ```

4. 将补丁程序保存到文件中：

   ```bash
   diff -Naur cello.c.orig cello.c > cello-output-first-patch.patch
   ```

5. 恢复原始`cello.c`:

   ```bash
   cp cello.c.orig cello.c
   ```

> 我们保留原始文件`cello.c`，因为在构建RPM时，会使用原始文件，而不是修改过的文件。

`cello.c`要使用补丁`cello.output-first-patch.patch`,请将补丁文件重定向到`patch`命令：

```bash
patch < cello-output-first-patch.patch
```

构建并运行修补程序`cello.c`:

```bash
make clean
make
./cello
```

您已经创建了一个补丁，修补了一个程序，构建了修补程序并运行它。