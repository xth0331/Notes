# CPU系统拓扑，调度与中断请求管理

## 系统拓扑

现代计算机技术，一个“*中央*”处理单元的观念是误导性的。因为大部分现代化的系统都有多个处理器。这些处理器是如何相互连接的，并且如何连接至其他系统资源——“系统拓扑“会对系统和应用的性能以及系统调节选项产生影响。

现代计算机技术主要运用两种主要拓扑类型

**SMP拓扑**

​	SMP（对称多处理器）拓扑允许所有的处理器同时访问内存。然而，由于内存访问权限的共享性和平等性，固然会迫使所有CPU及SMP系统序列化的内存访问权限的局限性增加，目前这种情况不被接受，几乎所有服务器系统都是NUMA（非一致性内存访问）。

**NUMA拓扑**

​	相比SMP，NUMA（非一致性内存访问）拓扑是近来开发的。在NUMA系统中，多个处理器分组至一个socket。每个socket都有一个专用内存区，对该内存进行本地访问的服务器统称为一个节点。

同一个节点上的服务器能告诉访问该节点的存储体，但访问其他节点上的存储体就比较慢，因此，访问非本地存储体会造成性能的损失。

考虑性能损失，服务器执行应用程序时，NMUA拓扑结构系统中对性能明爱的应用程序应访问同一个节点的内存，并且尽可能地避免访问任何远程内存。

因此，调节NUMA拓扑结构系统中的应用程序性能时，重要的是要考虑这一应用程序的执行点以及最靠近此执行点的存储体。

在NUMA拓扑结构系统中，`/sys`文件系统包含处理器、内存及外围设备连接信息。`/sys/devices/system/cpu`目录包含处理器在系统中相互连接的详情。`/sys/devices/system/node`目录包含系统中NUMA的节点信息以及节点间的相对距离。

### 确定系统拓扑结构

很多指令可以了解系统的 拓扑结构。`numactl --hardware`指令概述了系统的拓扑结构。

```bash
numactl --hardware
```

`lscpu`指令由`util-linux`包提供。包括CPU体系结构信息。

```bash
lscpu
```

`lstopo` 指令由`hwloc`包提供，创建了用户的系统示意图。`lstopo-no-graphics`指令提供了详尽的文本输出。

```bash
lstopo-no-graphics
```

## 调度

执行进程的最小单元是*线程*。系统调度器决定运行线程的处理器和运行的时间。但由于调度器主要关注的是保持系统繁忙，因此可能不会为应用程序的性能而对线程进行最佳调度。

例如，在NUMA系统中，一个处理器在节点B可用，一个应用程序在节点A运行，要是在节点B的处理器保持忙碌，调度器会把应用程序的一个线程转移到节点B。但是线程上的应用程序仍需要访问节点A的内存。由于该线程目前在B节点运行，并且对于此线程来说节点A的内存已不是本地内存，访问起来就要花更长的时间。较于在节点A等待可用的处理器，并且在能够进行本地内存访问的源节点上执行线程，此线程在节点B结束运行可就更加费时。

设计器或管理员确定线程的运行位置能使性能敏感的应用程序从中受益。



### Kernel Ticks

早期Linux版本中，Linux内核会定期中断每个CPU以查看需完成的任务。查看的结果用来决定进程调度及负载均衡均衡。这种常规性的中断叫做一个Kernel Ticks。

此标记的出现不考虑内核是否有任务要执行。这意味着为了回应这些中断，即使是空闲的内核也会被迫定期进入高能状态（高达每秒1000次）。这阻止了系统有效地利用x86处理器的深睡眠状态。

新版本中，默认情况下内核不再中断趋于低功率状态的空闲CPU，叫做无时钟内核。当一个或多个任务在运行时，按需中断取代了定时中断，使CPU可以更久地处于空闲状态或低功率状态，较少电量消耗。

7版本中提供了一种动态无时钟设置（`nohz_full`），通过用户空间的任务来减少内核干扰以进一步改善确定性。这一设置可以在指定的内核中通过`nohz_full`内核参数来启用。当这一设置在一个内核中启用时，所有的计时活动将会被移动至无延迟敏感性的内核。这对于高性能计算和实时计算工作负载来说都很有用，因为用户空间任务对于内核计时器Ticks信号造成 