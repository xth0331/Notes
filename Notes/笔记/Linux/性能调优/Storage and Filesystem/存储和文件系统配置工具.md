# 存储和文件系统配置工具

## 配置存储性能的Tuned配置文件

`tuned`服务提供了许多配置文件，旨在提高特定用例的性能。以下配置文件对于提高存储性能很有用。

- latency-performance（延迟性能）
- throughput-performance（吞吐量性能）默认

要在系统上配置配置文件，运行以下命令，将NAME替换为要是用的配置文件的名称。

```bash
tuned-adm profile NAME
```

`tuned-adm recommended` 命令为系统建议适当的配置文件。

## 设置默认I/O调度器

默认I/O调度器是在没有为设备明确指定其他调度器时使用的调度器。

如果未指定默认调度器，则`cfq`调度器用于SATA设备，`deadline`调度器用于所有其他设备。如果按照本说明指定默认调度器，则该默认调度器将应用于所有设备。

要设置默认I/O调度器，可以使用`Tuned`工具，也可以手工修改`/etc/default/grub`文件。

建议使用`tuned`工具在引导的系统上指定默认调度器。要设置`elevator`参数，启用`disk`插件。

要使用`GRUB2`修改默认调度程序，在引导或系统引导时将`elevator`参数附加到内核命令行。可以使用`tuned`工具，也可以手动修改`/etc/default/grub`文件。



### 使用GRUB2设置默认调度器

在引导的系统上设置默认I/O调度器，并在从新引导后使配置保持不变：

1. 添加`elevator`参数到`/etc/default/grub`文件的`GRUB_CMDLINE_LIUNX`行。

   ```bash
   cat /etc/default/grub
   
   
   GRUB_CMDLINE_LINUX="crashkernel=auto" rd.lvm.lv=/vg00/lvroot rd.lvm.lv=vg--/lvswap elevator
   ```

   可用的调度器有`deadline`，`noop`和`cfq`。

2. 添加`elevator`参数创建新配置。`GRUB2配置文件的位置在具有BIOS固件的系统和具有UEFI的系统上是不同的。使用以下命令之一重建GRUB2配置文件。

   - 在具有BIOS固件的系统上，使用：

     ``````bash
     grub-mkconfig -o /etc/grub2.cfg
     ``````

   - UEFI，使用：

     ```bash
     grub2-mkconfig -o /etc/grub2-efi.cfg
     ```

     

3. 重新引导系统生效。

   

## 通用块设备调整参数

通用调整参数位于`/sys/block/sdX/queue`目录中。列出的调整参数与I/O调度器调整分开，适用于所有I/O调度器。

- **add_random**

  一些I/O事件可能会影响`/dev/random`。如果这些影响变得可测量，该参数可以设置为`0`。

- **iostats**

  默认值为`1`（启用）。将`iostats`设置为`0`将禁用设备的I/O统计信息收集，从而消除I/O路径的少量开销。将`iostats`设置为`0`可能会略微提高高性能设备（如默写NVMe固态存储设备）的性能。除非供应商为给定的存储模型另行指定，否则建议启用`iostats`。

  如果禁用，则`/proc/diskststs`文件中不再存在该设备的I/O统计信息。`/proc/diskststs`的内容是用于监控I/O工具的I/O信息来源，例如`sar`或`iostats`。因此，如果禁用设备的`ioststs`参数，则I/O监控工具的输出中将不存在该设备。

- **max_sectors_kb**

  指定I/O请求的最大大小（KB为单位），默认值为512KB。此参数的最小值由存储设备的逻辑块大小决定。此参数的最大值由`max_hw_sectors_kb`的值决定。

  当I/O请求大于内部擦除块大小时吗，某些固态硬盘性能很差。建议`max_sectors_kb`始终是最佳I/O大小和内部擦除块大小的倍数。如果任意参数为零活存储设备未指定，则使用`logical_block_size`的值。

- **nomerges**

  大多数工作负载受益于请求合并。但是，禁用合并可能会对调试有用，默认情况下，`nomerges`参数设置为`0`，这将启用合并。要禁用简单的一键合并，将`nomerges`设置为`1`，要禁用所有类型的合并，请将`nomerges`设置为`2`。

- **nr_requests**

  指定一次可排队的最大读写请求数。默认为128，这意味着在下一个请求读取或写入进入休眠状态进程之前，可以将128个读取请求和128个写入请求排队。

  对于对延迟敏感的应用程序，请降低此参数的值并限制存储上的命令队列深度，以便回写I/O无法使用写入请求填充设备队列。当设备队列填满时，其他尝试执行I/O操作的进程进入休眠状态，直到队列空间可用。然后以循环方式分配请求，这防止了一个进程连续消耗队列中的所有点。

  I/O调度器中的最大I/O操作数为`nr_requests * 2`如上所述，`nr_requests`单独应用于读取和写入。注意，`nr_requests`仅适用于I/O调度器中的I/O操作，而不适用于已分派到底层设备的I/O操作。因此，针对设备的I/O操作的最大突发限制是`(nr_requests * 2 = (quere_depth)`其中`queue_depth`是`/sys/block/sdN/device/queue_depth`，有时也成为LUN队列深度。可以查看此I/O操作总数，例如`iostat`输出的`avgqu-sz`列。

- **optimal_io_size**

  某些存储设备通过此参数报告最佳I/O大小。如果报告此值，建议应用程序尽可能以最佳I/O大小的倍数发出I/O。

- **read_ahead_kb**

  定义在顺序读操作期间操作系统可以读取最大千字节数。因此，可能需要的信息已存在于内核页面缓存中，以便进行下一次顺序读取，从而提高读取I/O性能。

  设备映射通常受益于高于`read_ahead_kb`值。每个要映射的设备128KB是一个很好的起点。但是将`read_ahead_kb`值增加到4-8MB可能会提高在大文件顺序读取的应用程序环境中的性能。

- **rotational**

  某些固态磁盘无法正确通告其固态状态，并作为传统磁盘安装。如果固态设备没有自动将其设置为`0`，需要手动设置它以在调度程序中禁用不必要的寻道减少逻辑。

-  **rq_affinity**

  默认情况下，可以在发出I/O请求的处理器不同的处理器上处理I/O完成。将`rq_affinity`设置为`1`可禁用此功能，并仅在发出I/O请求的处理器上执行完成。这可以提高处理器数据缓存的有效性。

- **scheduler**

  要为特定存储设备设置调度器或调度器首选项顺序，需要编辑`/sys/block/DEVNAME/queue/scheduler`文件。

  ```bash
  echo cfq > /sys/block/sdb/queue/scheduler
  ```

  

