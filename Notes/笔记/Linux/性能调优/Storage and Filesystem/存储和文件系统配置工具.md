# 存储和文件系统配置工具

## 配置存储性能的Tuned配置文件

`tuned`服务提供了许多配置文件，旨在提高特定用例的性能。以下配置文件对于提高存储性能很有用。

- latency-performance（延迟性能）
- throughput-performance（吞吐量性能）默认

要在系统上配置配置文件，运行以下命令，将NAME替换为要是用的配置文件的名称。

```bash
tuned-adm profile NAME
```

`tuned-adm recommended` 命令为系统建议适当的配置文件。

## 设置默认I/O调度器

默认I/O调度器是在没有为设备明确指定其他调度器时使用的调度器。

如果未指定默认调度器，则`cfq`调度器用于SATA设备，`deadline`调度器用于所有其他设备。如果按照本说明指定默认调度器，则该默认调度器将应用于所有设备。

要设置默认I/O调度器，可以使用`Tuned`工具，也可以手工修改`/etc/default/grub`文件。

建议使用`tuned`工具在引导的系统上指定默认调度器。要设置`elevator`参数，启用`disk`插件。

要使用`GRUB2`修改默认调度程序，在引导或系统引导时将`elevator`参数附加到内核命令行。可以使用`tuned`工具，也可以手动修改`/etc/default/grub`文件。



### 使用GRUB2设置默认调度器

在引导的系统上设置默认I/O调度器，并在从新引导后使配置保持不变：

1. 添加`elevator`参数到`/etc/default/grub`文件的`GRUB_CMDLINE_LIUNX`行。

   ```bash
   cat /etc/default/grub
   
   
   GRUB_CMDLINE_LINUX="crashkernel=auto" rd.lvm.lv=/vg00/lvroot rd.lvm.lv=vg--/lvswap elevator
   ```

   可用的调度器有`deadline`，`noop`和`cfq`。

2. 添加`elevator`参数创建新配置。`GRUB2配置文件的位置在具有BIOS固件的系统和具有UEFI的系统上是不同的。使用以下命令之一重建GRUB2配置文件。

   - 在具有BIOS固件的系统上，使用：

     ``````bash
     grub-mkconfig -o /etc/grub2.cfg
     ``````

   - UEFI，使用：

     ```bash
     grub2-mkconfig -o /etc/grub2-efi.cfg
     ```

     

3. 重新引导系统生效。

   

## 通用块设备调整参数

通用调整参数位于`/sys/block/sdX/queue`目录中。列出的调整参数与I/O调度器调整分开，适用于所有I/O调度器。

- **add_random**

  一些I/O事件可能会影响`/dev/random`。如果这些影响变得可测量，该参数可以设置为`0`。

- **iostats**

  默认值为`1`（启用）。将`iostats`设置为`0`将禁用设备的I/O统计信息收集，从而消除I/O路径的少量开销。将`iostats`设置为`0`可能会略微提高高性能设备（如默写NVMe固态存储设备）的性能。除非供应商为给定的存储模型另行指定，否则建议启用`iostats`。

  如果禁用，则`/proc/diskststs`文件中不再存在该设备的I/O统计信息。`/proc/diskststs`的内容是用于监控I/O工具的I/O信息来源，例如`sar`或`iostats`。因此，如果禁用设备的`ioststs`参数，则I/O监控工具的输出中将不存在该设备。

- **max_sectors_kb**

  指定I/O请求的最大大小（KB为单位），默认值为512KB。此参数的最小值由存储设备的逻辑块大小决定。此参数的最大值由`max_hw_sectors_kb`的值决定。

  当I/O请求大于内部擦除块大小时吗，某些固态硬盘性能很差。建议`max_sectors_kb`始终是最佳I/O大小和内部擦除块大小的倍数。如果任意参数为零活存储设备未指定，则使用`logical_block_size`的值。

- **nomerges**

  大多数工作负载受益于请求合并。但是，禁用合并可能会对调试有用，默认情况下，`nomerges`参数设置为`0`，这将启用合并。要禁用简单的一键合并，将`nomerges`设置为`1`，要禁用所有类型的合并，请将`nomerges`设置为`2`。

- **nr_requests**

  指定一次可排队的最大读写请求数。默认为128，这意味着在下一个请求读取或写入进入休眠状态进程之前，可以将128个读取请求和128个写入请求排队。

  对于对延迟敏感的应用程序，请降低此参数的值并限制存储上的命令队列深度，以便回写I/O无法使用写入请求填充设备队列。当设备队列填满时，其他尝试执行I/O操作的进程进入休眠状态，直到队列空间可用。然后以循环方式分配请求，这防止了一个进程连续消耗队列中的所有点。

  I/O调度器中的最大I/O操作数为`nr_requests * 2`如上所述，`nr_requests`单独应用于读取和写入。注意，`nr_requests`仅适用于I/O调度器中的I/O操作，而不适用于已分派到底层设备的I/O操作。因此，针对设备的I/O操作的最大突发限制是`(nr_requests * 2 = (quere_depth)`其中`queue_depth`是`/sys/block/sdN/device/queue_depth`，有时也成为LUN队列深度。可以查看此I/O操作总数，例如`iostat`输出的`avgqu-sz`列。

- **optimal_io_size**

  某些存储设备通过此参数报告最佳I/O大小。如果报告此值，建议应用程序尽可能以最佳I/O大小的倍数发出I/O。

- **read_ahead_kb**

  定义在顺序读操作期间操作系统可以读取最大千字节数。因此，可能需要的信息已存在于内核页面缓存中，以便进行下一次顺序读取，从而提高读取I/O性能。

  设备映射通常受益于高于`read_ahead_kb`值。每个要映射的设备128KB是一个很好的起点。但是将`read_ahead_kb`值增加到4-8MB可能会提高在大文件顺序读取的应用程序环境中的性能。

- **rotational**

  某些固态磁盘无法正确通告其固态状态，并作为传统磁盘安装。如果固态设备没有自动将其设置为`0`，需要手动设置它以在调度程序中禁用不必要的寻道减少逻辑。

-  **rq_affinity**

  默认情况下，可以在发出I/O请求的处理器不同的处理器上处理I/O完成。将`rq_affinity`设置为`1`可禁用此功能，并仅在发出I/O请求的处理器上执行完成。这可以提高处理器数据缓存的有效性。

- **scheduler**

  要为特定存储设备设置调度器或调度器首选项顺序，需要编辑`/sys/block/DEVNAME/queue/scheduler`文件。

  ```bash
  echo cfq > /sys/block/sdb/queue/scheduler
  ```

## 调整Deadline调度器

使用`deadline`调度器时，排队的I/O请求将分类为读取或写入批处理，然后按增加的LBA顺序计划执行。默认情况下，读取批次由于写入批次，因为应用程序更可能阻塞读取I/O。处理批处理后，`deadline`会检查写入操作缺少处理器时间的时间，并更具需要调度下一个读取或写入批处理。

以下参数会影响`deadline`调度器的行为。

- **fifo_batch**

  要在单位批处理中读操作或写操作发出的数量。默认值为`16`。值越高，吞吐量也就越多，但也会增加延迟。

- **front_merges**

  如果工作负载永远不产生正面合并，可调整的参数设置为`0`但是，除非已经测量了此检查的开销，否则建议使用默认值`1`。

- **read_expire**

  应为服务调度读取请求的毫秒数。默认为500(0.5秒)。

- **write_expire**

  应为服务调度写入请求的毫秒数。默认值为5000（5秒）。

- **write_starved**

  在处理写入批吹之前可以吹的已读批处理的数量。设置的值越高，读取批次的优先级越高。



## 调整cfq调度器

当CFQ正在使用时，进程分为三类：实时，尽力而为和空闲。所有实时进程都在任何尽力而为进程之前进行调度，这些进程在任何空闲进程之前进行调度。默认情况下，流程被归类为尽力而为。可以使用`ionice`命令手动调整进程的类型。

可以使用以下参数进一步调整CFQ调度器的行为。通过更改`/sys/block/devname/queue/iosched`目录下的指定文件，可以基于每个设备设置这些参数。

- **back_seek_max**

  CFQ将执行向后搜索的最大距离（以千字节为单位）。默认为16KB。向后搜索通常会损害性能，因此不建议使用大值。

- **back_seek_penalty**

  当磁头决定是向前还是向后移动时，应用于向后搜索的乘数。默认值为`2`如果磁头位置为1024KB，并且系统中存在等距请求（例如，1008KB和1040KB），则`back_seek_penalty`将应用于向后搜索距离，磁盘将向前移动。

- **fifo_expire_async**

  异步（缓冲写入）请求可以保持不被服务的时间长度（以毫秒为单位）。在这段时间过期后，一个饥饿的异步请求被移动到调度列表。默认值为250毫秒。

- **fifo_expire_sync**

  同步（读取或者O_DIRECT写入）请求以毫秒计算的可能持续无服务的时间的长度。在这段时间过后，单个饥饿的同步请求被移动到调度列表。默认为125毫秒。

- **group_idle**

  默认情况下，此参数设置为0（禁用）。设置为1（启用）时，`cfq`调度器在控制组中发出I/O的最后一个进程上空闲。当使用比例权重I/O控制组并且`slice_idel`设置为0（快速存储时）时，这非常有用。

- **group_isolation**

  默认情况下，此参数设置为0（禁用）。设置为1（启用）时，它可以在组之间提供更强的隔离，但会降低吞吐量，因为公平性应用与随机和顺序工作负载。禁用`group_isolation`时，仅向顺序工作负载提供公平性。

- **low_latency**

  默认情况下，此参数设置为1（启用）。启用后，`cfq`通过Wie在设备上发出I/O的每个进程提供300ms的最大等待时间来支持吞吐量的公平性。当此参数设置为`0`（禁用）时，将忽略目标延迟，并且每个进程都会收到一个完整时间片。

- **quantum**

  此参数定义`cfq`一次向一个设备发送的I/O请求数，主要限制队列深度。默认值为8个请求。正在使用的设备可能支持更大的队列深度，但增加队列深度会导致延迟增加，尤其是大的顺序写工作负载。

- **since_async**

  此参数定义分配给发出异步I/O请求的每个进程的时间片长度（毫秒为单位）。默认值为40毫秒。

- **since_idle**

  此参数指定`cfq`在等待进一步请求时空闲的时间长度（毫秒为单位）。默认值为`0`（队列或服务树级别没有空闲）。默认值非常适合外部RAID存储上的吞吐量，但会降低内部非RAID存储的吞吐量。因为他会增加搜索操作的总数。

- **slice_sync**

  此参数定义分配给发出同步I/O请求的每个进程的时间片长度（毫秒为单位）。默认值100毫秒。

### 调整CFQ以实现快速存储

> 建议不要将`cfq`调度器用于不会遭受大量查找惩罚的硬件，例如快速外部存储阵列或固态磁盘。如果要求在此存储上使用`cfq`，需要编辑以下配置文件。

- 设置`/sys/block/DEVNAME/queue/iosched/slice_idle`为`0`
- 设置`/sys/block/DEVNAME/queue/iosched/quantum`为`64`
- 设置`/sys/block/DEVNAME/queue/iosched/group_idel`为`1`



## 调整 noop调度器

`noop`I/O调度器主要用于使用快速存储的CPU绑定系统。此外，`noop`I/O调度器通常（但不是唯一）在虚拟机上执行对虚拟磁盘的I/O操作时使用。

> 没有特定`noop`I/O调度器的可调参数。

## 配置文件系统以提高性能

格式化存储设备或挂载格式化设备时，参数根据其值是否应当v奥配置而分配。

如果文件碎片或者资源争用引起性能损失，性能通常可通过重新配置文件系统而提高性能。

###　调优xfs

XFS默认格式化和挂载适合大多数工作负载。建议只在更改特定配置会对工作负载有益时对他们进行更改。

#### 格式化选项

- **目录块大小**

  目录块大小会影响每个I/O操作可以检索或修改的目录信息量。目录块大小值即文件系统块大小（默认情况下为4KB）。目录块大小最大值为64KB。

  对于指定的目录大小来说，大的目录比晓得目录需要更多I/O。因为和小目录块的系统相比，大目录块大小的系统每I/O操作会使用更多的处理能力。因此，根据工作负载，推荐使用尽可能小的目录和目录块大小。

  如文件系统笔大量写和大量读工作负载的列出项目数量少，推荐使用以下目录块大小。

  | 目录块大小 | 最大项（大量读操作） | 最大项（大量写操作） |
  | ---------- | -------------------- | -------------------- |
  | 4KB        | 100000-200000        | 1000000-2000000      |
  | 16KB       | 100000-1000000       | 1000000-10000000     |
  | 64KB       | >1000000             | >10000000            |

  > 使用`mkfs.xfs -l`选项指定目录快大小。

- **分配组**

  分配组是独立的结构，它为文件系统的一部分索引可用空间和分配`inode`。每个分配组都可以独立修改，只要并发操作影响不同的分配组，XFS就可以同时执行分配和解除分配操作。因此，可以在文件系统中执行的并发操作的数量等于分配组的数量。但是，由于执行并发操作的能力也收到能够执行操作的处理器数量限制，建议分配组的数量大于或等于处理器数量。

  多个分配组不能同时修改单个目录。因此，建议创建和删除大量文件的应用程序不会讲所有文件存储在单个目录中。

  > 配置分配组，使用`mkfs.xfs -d `

- **增长限制**

  如果在格式化之后（通过增加更多硬件或通过自动精简配置），需要增加文件系统的大小，由于分配组大小在完成格式化之后不能更改，请仔细考虑初始文件布局。

  必须根据文件系统最终能力，而非根据初始能力调节分配组大小。占据所有使用空间的文件系统中分配组数量不应超过数百，除非分配组处于最大尺寸（1TB）。因此，大部分文件系统推荐最大增长，允许文件系统是初始大小的十倍。

  增长RAID数组的文件系统时，由于设备大小必须与固定多个分配组大小对齐，以便新分配组表头在新增加的存储中对齐。由于几何在格式化之后不能被更改，因此新存储也必须与已有的存储几何一致，因此，在同一块设备上，不能优化不同几何的存储。

- **Inode大小和内联属性**

  如果`inode`有足够可用空间，XFS能直接将属性名称和值写入`inode`。由于不需要额外的I/O，这些内联属性性能能够被获取和修改，达到比获取单独的属性块更改的量级。

  默认`inode`大小为256bytes。其中只有大约100bytes大小可用于属性存储，取决于`inode`上存储的数据范围指针数量。格式化文件系统时，增加`inode`大小能增加存储属性可用的空间数量。

  属性名称和属性值 两者都收到最大大小254bytes的限制。如果名称或者值超过254bytes长度，该属性或被推送到单独的属性块，而不是以内联方式存储。

  > 使用`mkfs.xfs -i `选项配置`inode`参数。

- **RAID**

  如果使用软件RAID，`mkfs.xfs`会自动使用条带单元和宽度配置底层硬件。然而，如果使用硬件RAID，可能需要手动配置条带单元和宽度，因为并非所有硬件RAID设备都会导出此信息。

  > 使用`mkfs.xfs -d`选项配置条带单元和宽度。

- **日志大小**

  挂起的更改将在内存中聚合，直到触发同步事件，此时他们将写入日志。日志的大小决定了一次可以进行的并发修改的数量。它还确定可以在内存中聚合的最大更改量，以及因此将记录的数据写入磁盘的频率。较小的日志迫使数据比较大的日志更频繁的写回磁盘。但是，较大的日志使用更多内存来记录挂起的修改，因此内存有限的系统将无法从更大的日志中受益。

  当日志与底层条带单元对齐时，日志的性能会更好；也就是说，他们以条带单元边界开始和结束。

  > 要将日志与条带单元对齐，使用`mkfs.xfs -d`。
  >
  > 要配置日志大小，使用`mkfs.xfs -l size=LOGSIZE`

- **日志条带单元**

  使用RAID5或RAID6布局的存储设备上的日志写入在条带单元边界处开始和结束时可能表现更好。`mkfs.xfs`尝试自动设置适当的日志条带单元，但这取决于导出此信息的RAID设备。

  如果工作负载非常频繁地出发同步事件，则设置大型日志条带单元可能会损害性能，因为较小的写入需要填充到日志条带单元的大小，这会增加延迟。如果工作负载手日志写入延迟限制，则建议将日志条带化单元设置为1块，以便尽可能出发未对齐的日志写入。

  支持的最大日志条带单元是最大日志缓冲区（256KB）。因此，底层存储可能具有比可在日志上配置的更大的条带单元。在这种情况下，`mkfs.xfs`发出警告并设置32KB的日志条带单元。

  > 要配置日志条带单元，使用一下选项之一，其中N是要用作条带单元的块数，size是条带单元的大小（KB）。

  ```bash
  mkfs.xfs -l sunit=Nb
  mkfs.xfs -l su=size
  ```

  