# 影响存储和文件系统性能的因素

存储和文件系统性能适当设置在很大程度上取决于存储的目的，I/O和文件系统性能会受下列因素的影响：

- 数据的写入或读取模式
- 数据重新排列与底层对齐
- 块大小
- 日志大小和位置
- 记录访问时间
- 确保数据可靠性
- 预取数据
- 预分配磁盘空间
- 文件碎片
- 资源争用

## I/O调度器

I/O调度程序确定I/O操作在存储设备上运行的时间和持续时间。也被称为I/O elevator。

linux体用了三个I/O调度程序：

- **deadline**

  除了SATA磁盘为所有块设备的默认I/O调度器。`deadline`尝试为指向到达I/O调度器的请求提供有保障的延迟。该调度器适合大多数用例，尤其适用于读取操作比写入操作更频繁的请求。

  将排队的I/O请求分配为读或者写批处理，按照LBA递增顺序执行。默认设置下，读取批处理优先于写批处理，这是要因为应用程序可能组织读取I/O。批处理后，`deadline`检查写入操作因等待处理器世间而处于多久的饥饿状态，并且适当地调度下一个读批处理或写批处理。

- **cfq**

  默认调度器只适用于标识为SATA硬盘的设备。完全公平队列调度器，`cfq`，将进程分成第三个独立类型：实时，尽其所能和空闲。实时类别的进程总是先于尽其所能类别进程执行，而尽其所能类别进程总是在空闲类别进程之间执行。这意味着实时类别的进程可以使尽其所能和空闲进程等待处理器时间而忍受饥饿。默认设置下，分配进程到尽其所能类别。

  `cfq`使用历史数据来预测应用是否会在不久之后发出更多I/O请求。如果将有更多I/O请求，`cfq`空闲则会等待新的I/O，即使有来自其他进程的I/O在等待处理。

  因为有空闲的趋势，`cfq`调度器不应用与连接不会引起大量搜寻penalty（惩罚）的硬件，除非它为此目的的而被调整。`cfq`调度器也不应用于连接其他断续工作型调度器，例如基于主机的硬件`RAID`控制器，因为这些调度器的堆叠有造成大量延迟的趋势。

- **noop**

  `noop`I/O调度器实现了简单的FIFO（先入先出）调度算法。请求通过简单的最后命中缓存在通用块层合并。对于使用快速存储的CPU绑定系统，这可能是最佳调度器。

##  文件系统

### XFS

XFS是一个强大且高度可拓展的64位文件系统。他是CentOS7的默认文件系统。XFS使用基于区段的分配，并具有多种分配方案，包括预先分诶和延迟的分配，这两种都会减少碎片和提高性能。它还支持故障恢复的元数据日志。当挂载并激活时，能够对XFS进行碎片整理。

XFS支持最大容量可达500TB的文件系统，以及最大容量为8EB的文件偏移量（稀疏文件）。

### EXT4

ext4是ext3文件系统的可缩放扩展。它的默认行为对大部分工作负载是最佳的。然而，它只支持最大容量为50TB的文件系统以及最大容量为16TB的文件。



### Btrfs

Btrfs（B-tree文件系统）是一种相对较新的写时复制（COW）文件系统，作为技术预览发布。一些独特的Btrfs功能包括：

- 特定文件，卷或子卷而不是整个文件系统的快照；
- 支持多种廉价磁盘冗余阵列（RAID）；
- 返回将映射I/O错误引用到文件系统对象；
- 透明压缩（分区上的所有文件都自动压缩）;
- 数据和元数据的校验和。

虽然Btrfs被认为是一个稳定的文件系统，但它还在不断发展，因此与更成熟的文件系统相比，某些功能（修复工具）是最基本的。

目前当需要高级功能（例如快照没压缩和文件数据校验和）时，选择Btrfs是合适的，但性能相对不重要。如果不需要高级功能，则失败和风险相对较弱的性能会使其他文件系统更受欢迎。与其他文件系统相比，另一个缺点是支持的最大文件系统大小为50TB。



### GFS2

全局文件系统2（GFS2）是一个高可用行附加组件的一部分，提供集群文件系统支持。GFS2在集群中的所有服务器上提供一致的文件系统影响，允许服务器通中读取和写入单个共享文件系统。

支持GFS2，最大文件系统大小为100TB。

## 文件系统的调整注意事项

### 格式化时的注意事项

格式化设备后，无法更改某些文件系统部分的配置，格式化存储设备前要做的决定和可用选项。

- **Size**

  按照工作负载创建合理大小的文件系统。较小的文件系统具有相应较短的备份时间，并且需要较少的时间和内存来进行文件系统检查。但是如果你的文件系统太小，其性能将受到高度碎片的影响。

- **Block size**

  块是文件系统的工作单元。块大小决定了单个块中可以存储多少数据，因此可以确定一次写入或读取的最小数据量。

  默认块大小适用于大多数用例。但是如果块大小（或多个块的大小）与通常一次读取或写入的数据量相同或稍大，则文件系统将更好地执行并有效低存储数据。一个小文件仍将使用整个块。文件可以分布在多个块上，但这回产生额外的运行时开销。此外，某些文件系统仅限于一定数量的块，这反过来限制了文件系统的最大大小。

  使用`mkfs`命令格式化设备时，块大小被指定为文件系统选项的一部分。指定块大小的参数因文件系统而异。

- **Geometry**

  文件系统几何涉及跨文件系统的数据分布。如果系统使用条带存储（如RAID），则可以在格式化设备时通过将数据和元数据与基础数据集合对齐来提高性能。

  很多数据导出的推荐集合在使用特定文件系统格式化设备时会被自动设置。如果设备没有导出这些推荐几何，或想要变更推荐设置，使用`mkfs`格式化设备时，需要手动指定几何。

- **External journals**

  日志文件系统记录在执行操作之前在日志文件中执行写操作期间所做的更改。这降低了存储设备在系统崩溃或电源故障时损坏的可能性，并加快了恢复过程。

  元数据密集型工作负载射击队日志频繁的更新。交大的日志使用更多内存，但会降低写入操作的频率。此外，通过将日志放在与主存储一样快或更快的专用存储上，可以改善具有元数据密集型工作负载的设备的查找时间。

### 挂载时的注意事项

> 适用于大部分文件系统的调整决定，且可在挂载设备时指定。

- **Barriers**

  文件系统屏障确保文件系统元数据在持久存储上正确编写和排序，并且`fsync`在断电时传输的数据仍然存在。

- **Access Time**

  每次读取文件时，其元数据都会根据访问发生的时间（atime）进行更新。这涉及额外的写入I/O。在大多数情况下，这种开销很小，因为默认情况下，`atime`只有当上一次访问时间早于上次修改（mtime）或状态更改（ctime）时，才会更新字段。

  但是，如果更新此元数据非常耗时，并且如果不需要准确的访问时间数据，则可以使用`noatime`mount选项挂载文件系统。这回在读取文件时禁用元数据更新。它还启用了`nodiratime`行为，在读取目录时禁用元数据更新。

- **Read-ahead**

  预读行为我通过预先获取可能很快需要的数据并将其加载到页面缓存中来加速文件访问，在页面缓存中可以比磁盘上更快地检索它。预读值越高，系统预取数据越早。

  Linux尝试根据检测到的文件系统设置适当的预读值。但是并不总是能够进行准确的检测。例如，如果存储阵列将自身作为单个LUN呈现给系统，则系统会检测单个LUN，并不会为阵列设置适当的预读值。

  设计大量顺序I/O流的工作负载通常受益于搞预读值。与使用LVM条带化一样，Linux提供的于存储相关的调优配置文件提高了预读值，但这些调整对于所有工作负载并不总是足够。



  ### 维护

  > 对于固态磁盘和精简配置存储，建议定期丢弃文件系统未使用的块。丢弃未使用块有两种方法：批量丢弃和在线丢弃。



- **Batch discard（批量丢弃）**

  这种丢弃是`fstrim`指令的一部分。它丢弃文件系统中与管理员指定的标准相匹配的所有不使用的块。

  > CentOS支持XFS和ext4格式化设备上的batch discard，这些设备实际丢弃操作即`/sys/block/devname/queue/discard_max_bytes`值不为0的HDD设备和`/sys/block/sda/queue/discard_granularity`不为0的SSD。

- **online discard（在线丢弃）**

  这种凡是的丢弃操作在挂载期间使用`discard`选项配置，实时运行不受用户干扰。然后。online discard只丢弃从使用转换到空闲的块。

  > 推荐使用batch discard 除非要求用 online discard 维持，或batch discard  不可用于系统工作负载。

- **Pre-allocation（预分配）**

  预分配将磁盘空间标记为已经将磁盘空间分配给一个文件，而未将数据写入该空间。这可用于限制数据碎片和交叉的读取性能。CentOS支持XFS、ext4、GFS2设备预分配空间。应用程序也可以通过`fallocate`、`glibc`调用预先分配空间。